from _typeshed import Incomplete
from talon import app as app
from talon.api import ffi as ffi, ffi_string as ffi_string, lib as lib
from talon.scripting import Dispatch as Dispatch
from talon.skia import Color as Color, Image as Image
from talon.types import Point2d as Point2d, Rect as Rect
from typing import Callable, Dict, Optional, Sequence, Tuple

class ScreenFingerprint:
    manufacturer: str
    model: str
    name: str
    serial: str
    from_left: int
    from_top: int
    from_right: int
    from_bottom: int
    depth: int
    scale: float
    dpi: float
    dpi_x: float
    dpi_y: float
    refresh_rate: float
    main: bool
    rect: Rect
    @classmethod
    def from_screen(self, screen: Screen) -> ScreenFingerprint: ...
    def pack(self) -> Dict: ...
    @classmethod
    def unpack(self, d: Dict) -> ScreenFingerprint: ...
    def compare(self, other: ScreenFingerprint) -> Tuple[bool, int]: ...
    def __init__(self, manufacturer, model, name, serial, from_left, from_top, from_right, from_bottom, depth, scale, dpi, dpi_x, dpi_y, refresh_rate, main, rect) -> None: ...

class Screen:
    depth: int
    scale: float
    dpi: float
    dpi_x: float
    dpi_y: float
    manufacturer: str
    model: str
    name: str
    serial: str
    mm_x: float
    mm_y: float
    refresh_rate: float
    main: bool
    @classmethod
    def from_c(cls, s: ffi.CData): ...
    @property
    def rect(self) -> Rect: ...
    @property
    def visible_rect(self) -> Rect: ...
    @property
    def fingerprint(self) -> ScreenFingerprint: ...
    x: Incomplete
    y: Incomplete
    width: Incomplete
    height: Incomplete
    def contains(self, x: float, y: float) -> bool: ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...

def screen_event(event: ffi.CData, c_screens: ffi.CData) -> None: ...

class ScreenMonitor(Dispatch):
    main_screen: Incomplete
    def __init__(self) -> None: ...
    @staticmethod
    def sort_screens(screens: list[Screen]) -> tuple[Optional[Screen], list[Screen]]: ...
    def screens(self) -> Sequence[Screen]: ...
    def screen_event(self, event: str, screens: list[Screen]) -> None: ...

def main(): ...
main_screen = main

def containing(x: float, y: float) -> Screen: ...
screen_containing = containing

def nearest(x: float, y: float) -> Screen: ...

register: Callable[[str, Callable], None]
unregister: Callable[[str, Callable], None]
screens: Callable[[], Sequence[Screen]]

def capture_window(win: int, x: float, y: float, width: float, height: float, retina: bool = ...) -> Image: ...
def capture_window_mac(win: int, rect: Rect = ..., retina: bool = ...) -> Image: ...
def capture_rect(rect: Rect, retina: bool = ...) -> Image: ...
def capture(x: float, y: float, width: float, height: float, retina: bool = ...) -> Image: ...
def get_pixel(x: float, y: float) -> Color: ...
