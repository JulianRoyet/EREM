from _typeshed import Incomplete
from talon import debug as debug
from talon.api import ffi as ffi, ffi_string as ffi_string, lib as lib
from typing import Dict, Iterable, List, Sequence, Set, Tuple

class WordModel:
    def compute(self, word: str) -> Sequence[Sequence[str]]: ...

class AlphaWordModel(WordModel):
    def compute(self, word: str) -> Sequence[Sequence[str]]: ...

class ExactWordModel(WordModel):
    def compute(self, word: str) -> Sequence[Sequence[str]]: ...

alpha_word_model: Incomplete

class NFA:
    starts: Set[int]
    ends: Set[int]
    nonce: int
    t_tokens: Dict[int, List[str]]
    t_edges: Dict[int, List[int]]
    epsilons: Dict[int, Set[int]]
    def __init__(self) -> None: ...
    def __eq__(self, other): ...
    @classmethod
    def blank(cls) -> NFA: ...
    @classmethod
    def word_selection(cls, words: List[str], *, word_model: WordModel = ...) -> NFA: ...
    @classmethod
    def from_strings(cls, *strings: str, word_model: WordModel = ...) -> NFA: ...
    @classmethod
    def word_list(cls, *words: str, word_model: WordModel = ...) -> NFA: ...
    def copy(self) -> NFA: ...
    def traverse(self, text: str, *, states: Set[int] = ...) -> Tuple[int, Iterable[int]]: ...
    def match(self, text: str) -> bool: ...
    def follow(self, states: Iterable[int], token: str) -> Set[int]: ...
    def size(self) -> int: ...
    def recompute_nonce(self) -> None: ...
    def next(self) -> int: ...
    def connect(self, src: int, token: str, dst: int) -> None: ...
    def connect_epsilon(self, src: int, dst: int) -> None: ...
    def orphan(self, src: int) -> None: ...
    def replace(self, target_state: int, nfa: NFA) -> int: ...
    def reversed(self) -> NFA: ...
    def epsilon_closure_inplace(self, states: Set[int]) -> None: ...
    def epsilon_closure(self, input_states: Iterable[int]) -> Set[int]: ...
    def epsilon_merge_inplace(self, states: Set[int]) -> None: ...
    def flatten_epsilons(self) -> None: ...
    def merge_transitions(self, *input_states: int) -> Tuple[List[str], List[int]]: ...
    def dfa(self) -> NFA: ...
    def minimize(self) -> NFA: ...
    def minimize_to_cfg(self, tokens: Sequence[str]) -> bytes: ...
    def graph(self): ...
