from _typeshed import Incomplete
from lark import Token as Token, Transformer, Tree as Tree
from typing import Callable, Optional, Sequence, Union

grammar: str

def lark_token_get(token) -> str: ...
def lark_pretty_error(text: str, e: Exception) -> str: ...
PathHook = Callable[[str], str]
Node: Incomplete
parser: Incomplete

class Container:
    children: Sequence[Node]
    def __init__(self, *children: Node) -> None: ...
    @classmethod
    def flat(cls, *children: Node) -> Node: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Seq(Container): ...
class Alt(Container): ...
class Opt(Container): ...
class Rep(Container): ...

class Leaf:
    name: str
    def __init__(self, name) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class RuleRef(Leaf): ...
class ListRef(Leaf): ...
class Literal(Leaf): ...

class TreeWalker(Transformer):
    path_hook: Incomplete
    def __init__(self, path_hook: PathHook = ...): ...
    def start(self, args: Sequence[Node]) -> Node: ...
    def sequence(self, args: Sequence[Node]) -> Node: ...
    def optional(self, args: Sequence[Node]) -> Node: ...
    def alternate(self, args: Sequence[Node]) -> Node: ...
    def term(self, args: Sequence[Union[Node, str]]) -> Node: ...
    def rule(self, args: Sequence): ...
    def list(self, args: Sequence): ...
    def literal(self, args: Sequence): ...

class ParseError(Exception): ...

spacing_re: Incomplete

def check_spacing(rule: str, stacklevel: int = ...) -> Optional[str]: ...
def parse_rule_uncached(rule: str, path_hook: PathHook = ...) -> Container: ...
def parse_rule(rule, path_hook: PathHook = ...) -> Container: ...
