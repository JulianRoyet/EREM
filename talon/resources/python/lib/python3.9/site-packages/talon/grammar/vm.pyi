import typing
from .vm_compile import VMRule as VMRule
from _typeshed import Incomplete

numbered_word_re: Incomplete
DEBUG: bool
builtin_rules: dict[str, list['Ins']]

class IndirectString(str): ...

class Phrase(IndirectString):
    def __iter__(self) -> typing.Iterator[str]: ...
    @property
    def words(self) -> typing.Sequence[str]: ...

class Capture:
    def __init__(self, vm_capture: VMCapture, sequence: list, mapping: dict) -> None: ...
    def __iter__(self) -> typing.Iterator: ...
    def __getitem__(self, key: typing.Union[str, int, slice]) -> typing.Any: ...
    def __getattr__(self, key: typing.Union[str, int, slice]) -> typing.Any: ...
    def __len__(self) -> int: ...

class VMListCapture:
    def __init__(self, name, value) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class VMCapture:
    def __init__(self, name, data=..., exact: int = ...) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __getitem__(self, key: int) -> typing.Any: ...
    def __iter__(self) -> typing.Iterator[typing.Any]: ...
    def flat(self, capture_mapper: typing.Callable[[VMCapture], typing.Any] = ..., list_mapper: typing.Callable[[str, str], str] = ...) -> Capture: ...
    def phrase(self) -> Phrase: ...
    def unmapped(self) -> list[str]: ...
    def rule_count(self, *, score: int = ...) -> list[int]: ...
    def exact_word_count(self) -> list[int]: ...

class State:
    rules: Incomplete
    generation: int
    phrase: Incomplete
    list_nfas: Incomplete
    pos: int
    enter_pos: int
    rule: Incomplete
    rule_name: str
    pc: int
    stack: Incomplete
    capture: Incomplete
    backrefs: Incomplete
    done: bool
    success: bool
    def __init__(self, rules, phrase, list_nfas: Incomplete | None = ...) -> None: ...
    def push(self, rule) -> None: ...
    def pop(self) -> None: ...
    def push_keys(self, keys) -> None: ...
    def pop_keys(self) -> None: ...
    def record(self, word, key: Incomplete | None = ..., exact: bool = ..., inc: int = ...) -> None: ...
    def copy(self): ...
    def words(self, n: int) -> typing.Sequence[str]: ...
    @property
    def word(self): ...
    @property
    def phrase_state(self): ...
    @property
    def good(self): ...

class VM:
    rules: dict[str, list['Ins']]
    def __init__(self, rules: dict[str, list['Ins']]) -> None: ...
    def parse(self, phrase, list_nfas: Incomplete | None = ..., timeout: int = ...): ...

class Ins:
    def run(self, state) -> None: ...
    def dis(self, line: Incomplete | None = ...) -> None: ...

class WordAny(Ins):
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

WordAnyOp: Incomplete

class Word(Ins):
    word: str
    iword: str
    def __init__(self, word: str) -> None: ...
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

class List(Ins):
    name: str
    def __init__(self, name) -> None: ...
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

class Fork(Ins):
    offsets: list[int]
    table: dict[str, list[int]]
    def __init__(self, *offsets, table: Incomplete | None = ...) -> None: ...
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

class Call(Ins):
    rule: str
    def __init__(self, rule) -> None: ...
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

class Return(Ins):
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

ReturnOp: Incomplete

class Jump(Ins):
    off: int
    def __init__(self, off) -> None: ...
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

class CapturePush(Ins):
    keys: Incomplete
    def __init__(self, keys) -> None: ...
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

class CapturePop(Ins):
    def run(self, state): ...
    def dis(self, line: Incomplete | None = ...): ...

CapturePopOp: Incomplete
