import enum
from . import parser as parser
from _typeshed import Incomplete
from typing import Dict, List, Tuple

dgn_def: Incomplete
dgn_def_size: Incomplete
dgn_header: Incomplete
dgn_header_size: Incomplete

class DragonType(enum.IntEnum):
    start: int
    end: int
    word: int
    rule: int
    list: int

class DragonVal(enum.IntEnum):
    seq: int
    alt: int
    rep: int
    opt: int

class DragonDefs(enum.IntEnum):
    words: int
    rules: int
    exports: int
    imports: int
    lists: int

class DragonCompileError(Exception): ...

rule_map: Incomplete
RuleDefs = List[Tuple[int, int]]

class DragonRule:
    grammar: DragonGrammar
    defs: RuleDefs
    def __init__(self) -> None: ...
    @classmethod
    def compile(self, grammar: DragonGrammar, root) -> RuleDefs: ...
    def walk(self, node) -> None: ...
    def emit(self, enum: int, value: int, prob: int = ...) -> None: ...

class DragonGrammar:
    autoimport: Incomplete
    name: Incomplete
    main_name: Incomplete
    rules: Incomplete
    words: Incomplete
    lists: Incomplete
    imports: Incomplete
    exports: Incomplete
    rule_defs: Incomplete
    invalid: Incomplete
    __invalid__: int
    def __init__(self, name: str) -> None: ...
    def use_id(self, table: Dict[str, int], name: str) -> int: ...
    def add_rule(self, name: str, root, public: bool = ...) -> None: ...
    def compile(self, main_root) -> bytes: ...
    @staticmethod
    def align4(n: int) -> int: ...
    def pack(self) -> bytes: ...
