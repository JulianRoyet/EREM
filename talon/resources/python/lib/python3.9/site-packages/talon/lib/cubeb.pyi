import weakref
from _typeshed import Incomplete
from collections import defaultdict as defaultdict
from enum import IntEnum, IntFlag
from talon import app as app
from talon.api import ffi as ffi, ffi_string as ffi_string, lib as lib
from talon.debug import log_exception as log_exception
from talon.lib.audio_queue import AudioQueue as AudioQueue
from talon.scripting import Dispatch as Dispatch, rctx as rctx
from typing import Dict, List, Optional

class SampleFormat(IntEnum):
    S16LE: int
    S16BE: int
    FLOAT32LE: int
    FLOAT32BE: int
    S16NE: Incomplete
    FLOAT32NE: Incomplete

class LogLevel(IntEnum):
    DISABLED: int
    NORMAL: int
    VERBOSE: int

class Channel(IntFlag):
    UNKNOWN: int
    FRONT_LEFT: Incomplete
    FRONT_RIGHT: Incomplete
    FRONT_CENTER: Incomplete
    LOW_FREQUENCY: Incomplete
    BACK_LEFT: Incomplete
    BACK_RIGHT: Incomplete
    FRONT_LEFT_OF_CENTER: Incomplete
    FRONT_RIGHT_OF_CENTER: Incomplete
    BACK_CENTER: Incomplete
    SIDE_LEFT: Incomplete
    SIDE_RIGHT: Incomplete
    TOP_CENTER: Incomplete
    TOP_FRONT_LEFT: Incomplete
    TOP_FRONT_CENTER: Incomplete
    TOP_FRONT_RIGHT: Incomplete
    TOP_BACK_LEFT: Incomplete
    TOP_BACK_CENTER: Incomplete
    TOP_BACK_RIGHT: Incomplete

class ChannelLayout(IntFlag):
    UNDEFINED: int
    MONO: Incomplete
    MONO_LFE: Incomplete
    STEREO: Incomplete
    STEREO_LFE: Incomplete
    QUAD: Incomplete
    QUAD_LFE: Incomplete

class StreamPrefs(IntFlag):
    NONE: int
    LOOPBACK: int
    DISABLE_DEVICE_SWITCHING: int
    VOICE: int
    RAW: int
    PERSIST: int
    JACK_NO_AUTO_CONNECT: int

class State(IntEnum):
    STARTED: int
    STOPPED: int
    DRAINED: int
    ERROR: int

class Result(IntEnum):
    OK: int
    ERROR: int
    ERROR_INVALID_FORMAT: int
    ERROR_INVALID_PARAMETER: int
    ERROR_NOT_SUPPORTED: int
    ERROR_DEVICE_UNAVAILABLE: int

class DeviceType(IntEnum):
    UNKNOWN: int
    INPUT: int
    OUTPUT: int

class DeviceState(IntEnum):
    DISABLED: int
    UNPLUGGED: int
    ENABLED: int

class DeviceFormat(IntEnum):
    S16LE: int
    S16BE: int
    F32LE: int
    F32BE: int
    S16NE: Incomplete
    F32NE: Incomplete
    S16_MASK: Incomplete
    F32_MASK: Incomplete

class DevicePref(IntFlag):
    NONE: int
    MULTIMEDIA: int
    VOICE: int
    NOTIFICATION: int
    ALL: int

class CubebError(Exception): ...

def set_log_level(level: LogLevel = ...): ...

class DeviceInfo:
    devid: Incomplete
    device_id: Incomplete
    name: Incomplete
    group_id: Incomplete
    vendor: Incomplete
    type: Incomplete
    state: Incomplete
    preferred: Incomplete
    format: Incomplete
    default_format: Incomplete
    max_channels: Incomplete
    default_rate: Incomplete
    max_rate: Incomplete
    min_rate: Incomplete
    latency_lo: Incomplete
    latency_hi: Incomplete
    def __init__(self, c: ffi.CData) -> None: ...
    def __eq__(self, other): ...

class StreamParams:
    format: Incomplete
    rate: Incomplete
    channels: Incomplete
    layout: Incomplete
    prefs: Incomplete
    def __init__(self, *, format: SampleFormat, rate: int, channels: int, layout: ChannelLayout = ..., prefs: StreamPrefs = ...) -> None: ...
    def to_c(self) -> ffi.CData: ...

DataCallback: Incomplete
StateCallback: Incomplete
StreamDeviceChangedCallback: Incomplete
DeviceCollectionChangedCallback: Incomplete

class Context(Dispatch):
    instances: Dict[ffi.CData, weakref.ReferenceType[Context]]
    context: Incomplete
    def __init__(self) -> None: ...
    def register_first(self, topic: str) -> None: ...
    @property
    def backend_id(self) -> str: ...
    @property
    def max_channel_count(self) -> int: ...
    @property
    def preferred_sample_rate(self): ...
    def get_min_latency(self, params: StreamParams) -> int: ...
    def new_stream(self, name: str, input_device: Optional[DeviceInfo], input_params: Optional[StreamParams], output_device: Optional[DeviceInfo], output_params: Optional[StreamParams], latency: int, data_cb: DataCallback, state_cb: StateCallback = ..., user_ptr: ffi.CData = ...) -> Stream: ...
    def new_input_stream(self, name: str, device: Optional[DeviceInfo], params: StreamParams, latency: int, data_cb: DataCallback, state_cb: StateCallback = ..., user_ptr: ffi.CData = ...) -> Stream: ...
    def new_output_stream(self, name: str, device: Optional[DeviceInfo], params: StreamParams, latency: int, data_cb: DataCallback, state_cb: StateCallback = ..., user_ptr: ffi.CData = ...) -> Stream: ...
    def devices(self, device_type: DeviceType) -> List[DeviceInfo]: ...
    def inputs(self) -> List[DeviceInfo]: ...
    def outputs(self) -> List[DeviceInfo]: ...
    def default_device(self, device_type: DeviceType) -> DeviceInfo: ...
    def default_input(self) -> DeviceInfo: ...
    def default_output(self) -> DeviceInfo: ...
    def __bool__(self) -> bool: ...
    def __del__(self) -> None: ...

class Stream(Dispatch):
    instances: Dict[ffi.CData, weakref.ReferenceType[Stream]]
    audio_queue: Optional[AudioQueue]
    context: Incomplete
    handle: Incomplete
    input_device: Incomplete
    input_params: Incomplete
    output_device: Incomplete
    output_params: Incomplete
    data_cb: Incomplete
    state_cb: Incomplete
    def __init__(self, context: Context, name: str, handle: ffi.CData, input_device: Optional[DeviceInfo], input_params: Optional[StreamParams], output_device: Optional[DeviceInfo], output_params: Optional[StreamParams], data_cb: DataCallback = ..., state_cb: StateCallback = ..., audio_queue: AudioQueue = ...) -> None: ...
    def register_first(self, topic: str) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    @property
    def stream_position(self) -> int: ...
    @property
    def latency(self) -> int: ...
    @property
    def input_latency(self) -> int: ...
    @property
    def current_device(self) -> DeviceInfo: ...
    @property
    def volume(self) -> float: ...
    @volume.setter
    def volume(self, value: float) -> None: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    def close(self) -> None: ...
    def __del__(self) -> None: ...
