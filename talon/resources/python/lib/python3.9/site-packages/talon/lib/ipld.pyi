import os
from _typeshed import Incomplete
from pathlib import Path
from typing import Dict, Iterator, List, Protocol, Tuple, Union

class uvarint:
    @classmethod
    def pack_into(cls, buf, offset: int, n: int) -> int: ...
    @classmethod
    def pack(cls, *values: int) -> bytes: ...
    @classmethod
    def unpack_from(cls, buf: bytes, offset: int = ...) -> Tuple[int, int]: ...
    unpack: Incomplete
    @classmethod
    def unpack_multi(cls, buf: bytes, count: int, offset: int = ...) -> Tuple[List[int], int]: ...

MULTIBASE_TABLE_CSV: str

class MultibaseSpec:
    name: str
    code: str
    description: str
    status: str
    def __init__(self, name, code, description, status) -> None: ...

class multibase:
    specs: Incomplete
    by_name: Incomplete
    by_code: Incomplete
    @classmethod
    def encode(cls, data: bytes, *, encoding: str = ..., code: bool = ...) -> str: ...
    @classmethod
    def decode(cls, data: str, *, encoding: str = ...) -> bytes: ...

MULTICODEC_TABLE_CSV: str

class MulticodecSpec:
    name: str
    tag: str
    code: int
    status: str
    description: str
    def __init__(self, name, tag, code, status, description) -> None: ...

class multicodec:
    specs: Incomplete
    by_name: Incomplete
    by_code: Incomplete

class Digest:
    name: str
    value: bytes
    def pack(self) -> bytes: ...
    def encode(self, encoding: str = ...) -> bytes: ...
    def __init__(self, name, value) -> None: ...

class multihash:
    class Hash:
        impls: Incomplete
        name: Incomplete
        impl: Incomplete
        def __init__(self, name: str, data: bytes = ...) -> None: ...
        def update(self, data: bytes) -> None: ...
        def digest(self) -> Digest: ...
    @classmethod
    def sha256(cls, data: bytes = ...) -> Hash: ...
    @classmethod
    def blake2b(cls, data: bytes = ...) -> Hash: ...
    @classmethod
    def new(cls, name: str, data: bytes = ...) -> Hash: ...
    @classmethod
    def pack(cls, name: str, digest: bytes) -> bytes: ...
    @classmethod
    def unpack(cls, buf: bytes) -> Digest: ...
    @classmethod
    def decode(cls, data: bytes) -> Digest: ...

class CID:
    codec: str
    digest: Digest
    version: int
    SPEC: Incomplete
    CODE_v1: Incomplete
    @classmethod
    def v1_raw(cls, data: bytes, codec: str = ...) -> CID: ...
    @classmethod
    def v0(cls, data: bytes) -> CID: ...
    def encode_binary(self) -> bytes: ...
    def encode(self, encoding: str = ...) -> str: ...
    @classmethod
    def decode_binary(cls, data: bytes) -> CID: ...
    @classmethod
    def decode(cls, data: str) -> CID: ...
    def __init__(self, codec, digest, version) -> None: ...

def pb_iter(data: bytes) -> Iterator[Tuple[int, int, Union[int, bytes]]]: ...
def pb_pack_header(field: int, wire: int) -> bytes: ...
def pb_pack_bytes(field: int, value: bytes) -> bytes: ...
def pb_pack_varint(field: int, value: int) -> bytes: ...

class DagLink:
    cid: CID
    name: str
    size: int
    @classmethod
    def from_dict(self, j: Dict) -> DagLink: ...
    def asdict(self): ...
    @classmethod
    def from_pb(self, buf: bytes) -> DagLink: ...
    def to_pb(self) -> bytes: ...
    def __init__(self, cid, name, size) -> None: ...

class DagNode:
    data: bytes
    links: List[DagLink]
    @classmethod
    def from_json(cls, data: bytes) -> DagNode: ...
    def to_json(self) -> bytes: ...
    @classmethod
    def from_pb(cls, buf: bytes) -> DagNode: ...
    def to_pb(self) -> bytes: ...
    def __init__(self, data, links) -> None: ...

class UnixNode:
    class Type:
        Raw: int
        Dir: int
        File: int
        Metadata: int
        Symlink: int
        HAMTShard: int
    type: int
    data: bytes
    size: int
    blocksizes: List[int]
    hashtype: int
    fanout: int
    mode: int
    mtime: int
    @classmethod
    def from_pb(cls, buf: bytes) -> UnixNode: ...
    def to_pb(self) -> bytes: ...
    def __init__(self, type, data, size, blocksizes, hashtype, fanout, mode, mtime) -> None: ...

class DiskUsage:
    value: int
    accuracy: str
    def __init__(self, value, accuracy) -> None: ...

class FlatStore:
    root: Path
    usage: DiskUsage
    SHARDING: str
    def __init__(self, root: str) -> None: ...
    def create(self, exist_ok: bool = ...) -> None: ...
    def delete(self, key: CID) -> bytes: ...
    def get(self, key: CID) -> bytes: ...
    def put(self, key: CID, data: bytes) -> None: ...
    def open(self, key: bytes, mode: str = ..., **kwargs): ...

class BlobFS(Protocol):
    def __contains__(self, addr: CID) -> bool: ...
    def get(self, addr: CID) -> bytes: ...
    def remove(self, addr: CID) -> None: ...
    def put(self, data: bytes, *, hash_type: str = ...) -> CID: ...

class WebFS(BlobFS):
    remotes: Incomplete
    session: Incomplete
    def __init__(self, *remotes: str) -> None: ...

class CacheFS(BlobFS):
    local: Incomplete
    remotes: Incomplete
    def __init__(self, local_path: os.PathLike, *remotes: BlobFS) -> None: ...
    def get(self, addr: CID) -> bytes: ...
    def put(self, data: bytes, *, codec: str = ..., hash_type: str = ...) -> CID: ...
    def remove(self, addr: CID) -> None: ...
    def open(self, addr: CID): ...
    def open_writer(self, *, codec: str = ..., hash_type: str = ...): ...
    def pin(self, cid: CID) -> None: ...
    def unpin(self, cid: CID) -> None: ...
    def gc(self) -> None: ...

class FlatFS(BlobFS):
    root: Path
    usage: DiskUsage
    SHARDING: str
    def __init__(self, root: str) -> None: ...
    def create(self, exist_ok: bool = ...) -> None: ...
    def delete(self, key: CID) -> bytes: ...
    def get(self, key: CID) -> bytes: ...
    def put(self, key: CID, data: bytes) -> None: ...
    def open(self, key: bytes, mode: str = ..., **kwargs): ...
