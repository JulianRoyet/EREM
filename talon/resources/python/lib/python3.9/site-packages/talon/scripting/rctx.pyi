from _typeshed import Incomplete
from talon import cron as cron, debug as debug
from talon.debug import log_exception as log_exception, object_name as object_name
from types import FrameType, TracebackType as TracebackType
from typing import Any, Callable, Iterator

class Resource:
    ctx: Incomplete
    def __init__(self, ctx: ResourceContext, enable_eval: str = ..., disable_eval: str = ..., free_eval: str = ..., scope: dict = ...) -> None: ...
    def defer_load(self) -> Resource: ...
    @property
    def scope(self) -> dict[str, Any]: ...
    def load(self) -> Resource: ...
    def unload(self) -> None: ...
    def free(self) -> None: ...

class ResourceManager:
    stacks: dict[int, list['ResourceContext']]
    contexts: set['ResourceContext']
    main: ResourceContext
    main_thread: int
    deferred: list[tuple[Callable[[], Any], FrameType]]
    exiting: bool
    def __init__(self) -> None: ...
    def defer(self, func: Callable[[], Any]) -> None: ...
    def flush(self) -> None: ...
    def stack(self) -> list['ResourceContext']: ...
    def active(self) -> ResourceContext: ...
    def is_machine(self) -> bool: ...
    def as_human(self, value: bool = ...) -> Iterator[None]: ...
    def register(__self__, *, disable_eval: str = ..., enable_eval: str = ..., free_eval: str = ..., **scope_kwargs) -> Resource: ...
    def context(self, name: str, ref: Any = ...) -> ResourceContext: ...
    def remove(self, ctx: ResourceContext) -> None: ...
    def cleanup(self) -> None: ...

class ResourceErr(Exception): ...
class ResourceUnmanaged(ResourceErr): ...
class ResourceClosed(ResourceErr): ...

class ResourceContext:
    manager: ResourceManager
    name: str
    file: str
    ref: Any
    path: str
    freed: bool
    resources: set[Resource]
    def __init__(self, manager: ResourceManager, name: str, ref: Any = ...) -> None: ...
    def assert_not_freed(self) -> None: ...
    def register(self, res: Resource) -> None: ...
    def unregister(self, res: Resource) -> None: ...
    def nonce(self) -> int: ...
    def free(self) -> None: ...
    def safe_call(self, topic: Any, cb: Callable, *args: Any, frame: FrameType = ...) -> Any: ...
    def parse_path(self, path: str, *, rel: bool = ...) -> str: ...
    def parse_path_implicit_self(self, path: str) -> str: ...
    def enter(self) -> Iterator[None]: ...

manager: Incomplete
active: Callable[[], ResourceContext]
context: Incomplete
cleanup: Incomplete
register: Incomplete
flush: Incomplete
defer: Incomplete
is_machine: Incomplete
as_human: Incomplete
main: ResourceContext

def path() -> str: ...
def parse_path(path: str) -> str: ...
def parse_path_implicit_self(path: str) -> str: ...
def safe_call(*args, **kwargs) -> Any: ...
