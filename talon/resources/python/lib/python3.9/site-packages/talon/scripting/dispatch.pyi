from _typeshed import Incomplete
from talon import cron as cron, debug as debug
from talon.scripting import rctx as rctx
from typing import Any, Callable, Dict, Generator, List, Tuple, TypeVar

async_queue: Incomplete

def async_call(fn: Callable[[], Any]) -> cron.Job: ...
EventKeyType = Tuple[Callable, rctx.ResourceContext]
EventDictType = Dict[Any, List[EventKeyType]]
DecoratedT = TypeVar('DecoratedT', bound=Callable[..., Any])

class Stop(Exception): ...

class Dispatch:
    events: EventDictType
    pre: EventDictType
    post: EventDictType
    def __new__(typ, *args, **kwargs): ...
    def __init__(self) -> None: ...
    def register_first(self, topic: Any) -> None: ...
    def unregister_last(self, topic: Any) -> None: ...
    def get_table(self, topic: Any) -> Tuple[EventDictType, Any]: ...
    def register(self, topic: Any, cb: Callable) -> None: ...
    def unregister(self, topic: Any, cb: Callable) -> None: ...
    def async_call(self, cb) -> None: ...
    def dispatch_async(self, topic: Any, *args: Any) -> None: ...
    def dispatch(self, topic: Any, *args: Any) -> List: ...
    def dispatch_pre(self, topic: Any, *args: Any) -> None: ...
    def dispatch_post(self, topic: Any, *args: Any) -> None: ...
    def dispatch_iter_direct(self, topic: Any, *args: Any) -> Generator[Any, None, None]: ...
    def dispatch_iter(self, topic: Any, *args: Any) -> Generator[Any, None, None]: ...
    def dispatch_block(self, topic: str, *args) -> Generator[Any, None, None]: ...

def wrap(func: DecoratedT) -> DecoratedT: ...
