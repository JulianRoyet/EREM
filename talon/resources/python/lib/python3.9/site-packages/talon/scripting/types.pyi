from .actions import ActionPath as ActionPath
from .context import Context as Context
from .match import Match as Match
from .module import Module as Module
from .registry import Registry as Registry
from .talon_script import TalonScript as TalonScript
from _typeshed import Incomplete
from talon.grammar import Capture as Capture, Rule as Rule
from types import MethodType as MethodType
from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Type, TypeVar, Union

SettingValue = Union[float, int, str, List[Any]]
DecoratedT = TypeVar('DecoratedT', bound=Callable[..., Any])
DecoratorType = Callable[[DecoratedT], DecoratedT]
T = TypeVar('T')
Class = TypeVar('Class', bound=Type)

class FreezeBase:
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __delattr__(self, name: str) -> None: ...

class ImmutableClassMeta(type):
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __delattr__(self, name: str) -> None: ...

class OpaqueClassMeta(type):
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __getattr__(self, name: str) -> None: ...
    def __delattr__(self, name: str) -> None: ...

class DuplicateError(Exception): ...

def parse_doc(func: Callable) -> Tuple[str, Dict[str, str]]: ...

class ActionProtoError(TypeError):
    def __init__(self, action: ActionDecl, problems: Sequence[str]) -> None: ...

class ActionImplError(TypeError):
    def __init__(self, decl: ActionDecl, impl: ActionImpl, problems: Sequence[str]) -> None: ...

class ActionDecl:
    mod: Module
    path: str
    default_impl: Optional['ActionImpl']
    desc: str
    params: Dict[str, str]
    proto: Incomplete
    def __init__(self, mod: Module, path: str, proto: Callable) -> None: ...
    def check_impl(self, impl: ActionImpl) -> None: ...

class CaptureDecl:
    mod: Module
    path: str
    default_impl: Optional['CaptureImpl']
    rule: Optional['Rule']
    desc: str
    type: type
    proto: Incomplete
    def __init__(self, mod: Module, path: str, proto: Callable, rule: Rule = ...) -> None: ...

class NameDecl:
    mod: Module
    path: str
    desc: Optional[str]
    def __init__(self, mod: Module, path: str, desc: str = ...) -> None: ...

class AppNamespace:
    def __init__(self, mod: Module, value_parser: Callable[[str, str], 'Match']) -> None: ...
    def __setitem__(self, key: str, value: str) -> None: ...
    def __setattr__(self, key: str, value: str) -> None: ...

class AppDecl:
    mod: Module
    name: str
    match: Match
    cm: ContextMatch
    def __init__(self, mod: Module, name: str, match: Match) -> None: ...
    def is_active(self) -> bool: ...

class ContextMatch:
    ctx: Union['Context', 'Module']
    match: Match
    def __init__(self, ctx: Union['Context', 'Module'], match: Match) -> None: ...

class SettingDecl:
    class NoValueType: ...
    NoValue: Incomplete
    mod: Module
    path: str
    type: Type[T]
    default: Union[T, NoValueType]
    desc: Optional[str]
    def __bool__(self) -> None: ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __gt__(self, other): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ne__(self, other): ...
    def __init__(self, mod: Module, path: str, type: Type[T], registry: Registry, *, default: Union[T, NoValueType] = ..., desc: str = ...) -> None: ...
    def process_value(self, value: T) -> T: ...
    def get_all(self, default: Union[T, NoValueType] = ...) -> Sequence[T]: ...
    def get(self, default: Union[T, NoValueType] = ...) -> T: ...

class ActionImpl:
    ctx: Union['Module', 'Context']
    path: str
    func: Union[Callable, 'TalonScript']
    type_decl: Optional[ActionDecl]
    type_err: Optional[ActionImplError]
    def __init__(self, ctx: Union['Module', 'Context'], path: str, func: Union[Callable, 'TalonScript']) -> None: ...
    def call(self, *args, **kwargs) -> Any: ...

class CaptureImpl:
    ctx: Union['Context', 'Module']
    path: str
    rule: Rule
    func: Incomplete
    def __init__(self, ctx: Union['Context', 'Module'], path: str, rule: Rule, func: Callable) -> None: ...
    def call(self, m: Capture) -> Any: ...

class CommandImpl:
    ctx: Context
    rule: Rule
    target: TalonScript
    experiments: set[str]
    def __init__(self, ctx: Context, rule: Rule, target: TalonScript, experiments: set[str] = ...) -> None: ...

class ScriptImpl:
    ctx: Context
    trigger: str
    script: TalonScript
    def __init__(self, ctx: Context, trigger: str, script: TalonScript) -> None: ...
