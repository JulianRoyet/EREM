from .match import Match as Match
from .module import Module as Module
from .registry import Decls as Decls, Registry as Registry
from .types import ContextMatch as ContextMatch
from _typeshed import Incomplete
from talon import events as events
from talon.scripting.dispatch import Dispatch as Dispatch
from talon.scripting.types import ImmutableClassMeta as ImmutableClassMeta, parse_doc as parse_doc
from typing import Any, Callable, Dict, Optional, Tuple

ScopeFunc = Callable[[], Dict]

class ScopeDecl(Dispatch):
    mod: Incomplete
    path: Incomplete
    func: Incomplete
    def __init__(self, mod: Module, path: str, func: ScopeFunc) -> None: ...
    def update(self, *args) -> None: ...

class Scope(Dispatch, metaclass=ImmutableClassMeta):
    app_decl: Incomplete
    lock: Incomplete
    registry: Incomplete
    data: Incomplete
    data_sources: Incomplete
    raw_data: Incomplete
    scopes: Incomplete
    registered: Incomplete
    def __init__(self, registry: Registry) -> None: ...
    def key(self, path: str) -> Tuple[str, Optional[str]]: ...
    def get(self, path: str, default: Any = ...) -> Any: ...
    def __contains__(self, path: str) -> bool: ...
    def __getitem__(self, path: str) -> Any: ...
    def matches(self, cm: ContextMatch) -> bool: ...
    def update(self, path: str) -> None: ...
    def update_one(self, scope: ScopeDecl) -> None: ...
    def update_decls(self, decls: Decls) -> None: ...
