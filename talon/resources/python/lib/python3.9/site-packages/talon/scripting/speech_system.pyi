import threading
from _typeshed import Incomplete
from talon import app as app, debug as debug, engines as engines, events as events, metrics as metrics
from talon.engines import AbstractEngine as AbstractEngine
from talon.experimental import screen_lock as screen_lock
from talon.grammar import Capture as Capture, Grammar as Grammar, Rule as Rule
from talon.grammar.vm import VMCapture as VMCapture
from talon.lib.cubeb import DeviceInfo as DeviceInfo
from talon.scripting import Dispatch as Dispatch, Settings as Settings, rctx as rctx
from talon.scripting.registry import Registry as Registry
from talon.vad import Vad as Vad
from typing import Dict, Optional, Sequence, Set, Union

class EngineProxy(Dispatch):
    engine: AbstractEngine
    enabled: bool
    mic: Optional[DeviceInfo]
    language: str
    grammars: Set[Grammar]
    def __init__(self, engine: AbstractEngine) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def subtype(self) -> str: ...
    @property
    def id(self) -> str: ...
    @property
    def ready(self) -> bool: ...
    def status(self) -> engines.EngineStatus: ...
    def enable(self) -> None: ...
    def disable(self) -> None: ...
    def set_microphone(self, device: Optional[DeviceInfo]) -> None: ...
    def mimic(self, phrase: Union[Sequence[str], str]) -> None: ...
    def sync_grammar(self, grammar: Grammar) -> None: ...
    def unload_grammar(self, grammar: Grammar) -> None: ...

class AnchorGroup:
    anchor_start: list[str]
    anchor_end: list[str]
    ccr_rules: list[str]
    def __init__(self, anchor_start, anchor_end, ccr_rules) -> None: ...

class SpeechSystem(Dispatch):
    settings: Settings
    registry: Registry
    lock: threading.RLock
    engines: Dict[AbstractEngine, EngineProxy]
    engine: Optional[EngineProxy]
    grammar: Optional[Grammar]
    priority: Dict[str, int]
    vad: Optional['Vad']
    ready: bool
    def __init__(self, registry: Registry = ...) -> None: ...
    def update_grammars(self) -> None: ...
    def update_lists(self, changed: Set[str] = ...) -> None: ...
    def pick_engine(self) -> None: ...
    def add_engine(self, engine: AbstractEngine) -> None: ...
    def remove_engine(self, engine: AbstractEngine) -> None: ...
    def engine_event(self, topic: str, engine: EngineProxy, j: Incomplete | None = ...): ...
    def parse(self, phrase: Union[Sequence[str], str]) -> Optional[VMCapture]: ...
    def mimic(self, phrase: Union[Sequence[str], str]) -> None: ...
    def engine_mimic(self, phrase: Union[Sequence[str], str]) -> None: ...
    def status(self): ...
