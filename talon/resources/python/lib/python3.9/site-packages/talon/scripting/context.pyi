from .registry import Registry as Registry
from .scope import Scope as Scope
from .talon_file import TalonFile as TalonFile
from .talon_script import TalonScript as TalonScript
from .types import ActionImpl as ActionImpl, CaptureImpl as CaptureImpl, Class as Class, CommandImpl as CommandImpl, ContextMatch as ContextMatch, DecoratedT as DecoratedT, DecoratorType as DecoratorType, DuplicateError as DuplicateError, ImmutableClassMeta as ImmutableClassMeta, OpaqueClassMeta as OpaqueClassMeta, ScriptImpl as ScriptImpl, SettingValue as SettingValue, T as T
from _typeshed import Incomplete
from collections import defaultdict as defaultdict
from talon.debug import log_exception as log_exception
from talon.grammar import Rule as Rule, parser as parser
from talon.scripting import rctx as rctx
from talon.scripting.actions import ActionClassProxy as ActionClassProxy
from talon.scripting.match import Match as Match
from typing import Any, Callable, ItemsView, Iterator, KeysView, Mapping, Optional, Protocol, Sequence, TypeVar, Union, ValuesView, overload

path_re: Incomplete
ListError: Incomplete

class ListMeta(dict[str, str]):
    def __ior__(self, value: Mapping[str, str]): ...
    def __iadd__(self, value) -> None: ...
    def __delitem__(self, key, value) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def insert(self, index, obj) -> None: ...
    def remove(self, value) -> None: ...
    def update(self, values) -> None: ...
    def clear(self) -> None: ...
    def pop(self, *args) -> None: ...
    def append(self, value) -> None: ...
    def extend(self, values) -> None: ...
    def sort(self) -> None: ...
    def popitem(self) -> None: ...
    def setdefault(self, key, default: Incomplete | None = ...) -> None: ...

def words_parse(key: str, value: Any, **kwargs) -> ListMeta: ...
T_co = TypeVar('T_co', covariant=True)
NoValue: Incomplete

class KeyParser(Protocol):
    def __call__(self, key: str) -> str: ...

class ValueParser(Protocol[T_co]):
    def __call__(self, key: str, value: Any, **kwargs) -> T_co: ...

class DictionaryMeta(dict[str, T]):
    ctx: Context
    def __init__(self, ctx: Context, event: str, key_parser: KeyParser = ..., value_parser: ValueParser[T] = ..., frozen: bool = ...): ...
    def __getitem__(self, key: str) -> T: ...
    def __setitem__(self, key: str, value: T) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    @overload
    def get(self, key: str) -> Optional[T]: ...
    @overload
    def get(self, key: str, default: Union[T, _T]) -> Union[T, _T]: ...
    def pop(self, key: str, default: Any = ...) -> Any: ...
    def items(self) -> ItemsView[str, T]: ...
    def keys(self) -> KeysView[str]: ...
    def values(self) -> ValuesView[T]: ...
    def set(self, values: dict[str, Any], *, skip_errors: bool = ..., **kwargs) -> None: ...
    def update(self, values, **kwargs) -> None: ...

class Context(metaclass=ImmutableClassMeta):
    name: str
    path: str
    desc: Optional[str]
    def __init__(self, name: str = ..., *, desc: str = ..., registry: Registry = ..., scope: Scope = ...): ...
    def action_class(self, path: str) -> Callable[[Class], ActionClassProxy]: ...
    def action(self, path: str): ...
    def capture(self, path: str = ..., *, rule: str = ...) -> DecoratorType: ...
    @property
    def matches(self) -> Union[str, Match]: ...
    @matches.setter
    def matches(self, matches: Union[str, Match]): ...
    @property
    def apps(self): ...
    @apps.setter
    def apps(self, value: Sequence[str]): ...
    @property
    def lists(self) -> dict[str, Mapping[str, str]]: ...
    @lists.setter
    def lists(self, lists: dict[str, Union[dict[str, str], Sequence[str]]]) -> None: ...
    @property
    def settings(self): ...
    @settings.setter
    def settings(self, value: dict[str, SettingValue]): ...
    @property
    def tags(self): ...
    @tags.setter
    def tags(self, value: Sequence[str]): ...
    @property
    def commands(self) -> Mapping[str, CommandImpl]: ...
    @property
    def hotkeys(self) -> Mapping[str, ScriptImpl]: ...
    @property
    def noises(self): ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
