import json
import sqlite3
from _typeshed import Incomplete
from talon.scripting.types import ImmutableClassMeta as ImmutableClassMeta
from typing import Any, Callable, Dict, Iterable, Optional, Sequence, Tuple, Type

class Codec:
    cls: Any
    name: str
    decode: Incomplete
    def __init__(self, cls: Any, name: str, encode: Callable[[Any], Any], decode: Callable[[Any], Any]) -> None: ...
    def encode(self, obj: Any) -> dict: ...
    def match(self, obj: Any) -> bool: ...

class CodecManager:
    codecs: dict[str, Codec]
    json_encoder: Type[json.JSONEncoder]
    def __init__(self): ...
    def nameof(self, cls: Any) -> str: ...
    def register(self, cls: Any, encode: Callable[[Any], Any], decode: Callable[[Any], Any]) -> None: ...
    def find(self, obj: Any) -> Optional[Codec]: ...
    def json_object_hook(self, obj: Any) -> Any: ...

codecs: Incomplete

class Storage(metaclass=ImmutableClassMeta):
    path_hook: Incomplete
    path: Incomplete
    lock: Incomplete
    transaction: bool
    db: Incomplete
    def __init__(self, path: str, path_hook: Callable[[str], str] = ...): ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def execute(self, query: str, bind: Tuple = ...) -> sqlite3.Cursor: ...
    def cursor(self) -> sqlite3.Cursor: ...
    class NoValue: ...
    def get(self, path: str, default: Any = ...) -> Any: ...
    def set(self, path: str, value: Any) -> None: ...
    @property
    def defaults(self) -> Dict[str, Any]: ...
    @defaults.setter
    def defaults(self, defaults: Dict[str, Any]) -> None: ...
    def remove(self, path: str) -> None: ...
    def iterkeys(self, pattern: str = ...) -> Iterable[str]: ...
    def keys(self, pattern: str = ...) -> Sequence[str]: ...
    def close(self) -> None: ...
    def __del__(self) -> None: ...
