from .registry import Registry as Registry
from .scope import Scope as Scope, ScopeDecl as ScopeDecl, ScopeFunc as ScopeFunc
from .types import ActionDecl as ActionDecl, AppDecl as AppDecl, AppNamespace as AppNamespace, CaptureDecl as CaptureDecl, Class as Class, DecoratedT as DecoratedT, DecoratorType as DecoratorType, DuplicateError as DuplicateError, ImmutableClassMeta as ImmutableClassMeta, NameDecl as NameDecl, OpaqueClassMeta as OpaqueClassMeta, SettingDecl as SettingDecl, T as T
from talon.grammar import parser as parser
from talon.scripting import Dispatch as Dispatch, rctx as rctx
from talon.scripting.actions import ActionClassProxy as ActionClassProxy
from talon.scripting.match import Match as Match
from typing import Optional, Type, Union, overload

class Module(metaclass=ImmutableClassMeta):
    path: str
    desc: Optional[str]
    apps: AppNamespace
    def __init__(self, desc: str = ..., registry: Registry = ..., scope: Scope = ...) -> None: ...
    def action_class(self, cls: Class) -> ActionClassProxy: ...
    def action(self, func: DecoratedT) -> ActionDecl[DecoratedT]: ...
    @overload
    def capture(self, *, rule: str) -> DecoratorType: ...
    @overload
    def capture(self, func: DecoratedT) -> DecoratedT: ...
    def scope(self, func: ScopeFunc) -> ScopeDecl: ...
    def setting(self, name: str, type: Type[T], default: Union[T, SettingDecl.NoValueType] = ..., desc: str = ...) -> SettingDecl[T]: ...
    def list(self, name: str, desc: str = ...) -> NameDecl: ...
    def mode(self, name: str, desc: str = ...) -> NameDecl: ...
    def tag(self, name: str, desc: str = ...) -> NameDecl: ...
