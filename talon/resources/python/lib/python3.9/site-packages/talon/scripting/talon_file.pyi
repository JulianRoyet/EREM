from _typeshed import Incomplete
from enum import IntEnum
from talon import app as app, debug as debug
from talon.scripting.match import Match as Match, MatchAny as MatchAny, MatchRegex as MatchRegex, MatchString as MatchString
from typing import Dict, List, Optional, Sequence

indent_rule: str
context_line: Incomplete
separator: Incomplete
special: str
def_line: Incomplete
indent_re: Incomplete
and_not_re: Incomplete
regex_re: Incomplete

class TalonFile:
    filename: str
    matches: Matches
    match_lines: list[str]
    definitions: Sequence['Definition']
    experiments: set[str]
    errors: Sequence['ParseError']
    def __init__(self, filename: str, matches: Matches, match_lines: list[str], definitions: Sequence['Definition'], experiments: set[str], errors: Sequence['ParseError']) -> None: ...
    @property
    def match_string(self) -> str: ...
    def print_errors(self) -> None: ...
    def __bool__(self): ...

class ParseError:
    msg: Incomplete
    line: Incomplete
    lineno: Incomplete
    col: Incomplete
    def __init__(self, msg: str, line: str, lineno: int, col: int = ...) -> None: ...

class Matches:
    key: Optional[str]
    top_level: Dict[str, List[Match]]
    def __init__(self) -> None: ...
    def push(self, key: str, value: str, _and: bool = ..., _not: bool = ...) -> Sequence[str]: ...
    def finalize(self) -> Match: ...
    def __bool__(self) -> bool: ...

class Definition:
    filename: str
    lineno: int
    trigger: str
    code: Sequence[str]
    tag: str
    block: bool
    def __init__(self, filename: str, lineno: int, trigger: str, code: Sequence[str], tag: str = ..., block: bool = ...) -> None: ...

class Mode(IntEnum):
    CONTEXT: int
    DEFINES: int
    ACTION_BLOCK: int

def parse(data: str, *, parse_mode: str = ..., input_file: str = ..., input_line: int = ...) -> TalonFile: ...
