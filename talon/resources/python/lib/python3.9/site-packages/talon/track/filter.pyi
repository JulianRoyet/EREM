import numpy as np
from _typeshed import Incomplete

class LowPassFilter:
    y: int
    def __init__(self) -> None: ...
    def __call__(self, x, alpha): ...

class OneEuroFilter:
    default: Incomplete
    first: bool
    mincut: Incomplete
    dxcut: Incomplete
    beta: Incomplete
    xfilt: Incomplete
    dxfilt: Incomplete
    def __init__(self, mincut, beta, dxcut) -> None: ...
    def alpha(self, dt, cutoff): ...
    def __call__(self, x, dt): ...

class DwellFilter:
    filt: Incomplete
    drift: Incomplete
    x: Incomplete
    radius: Incomplete
    def __init__(self, radius, one_euro_config=...) -> None: ...
    y: Incomplete
    def __call__(self, x, y, dt): ...

class MultiFilter:
    filts: Incomplete
    def __init__(self, cls, n, *args, **kwargs) -> None: ...
    def __call__(self, vals, *args, **kwargs): ...

class PointFilter:
    filts: Incomplete
    def __init__(self, cls, *args, **kwargs) -> None: ...
    def __call__(self, p, *args, **kwargs): ...

class Range:
    def __init__(self, _min, _max) -> None: ...
    def __contains__(self, x): ...

class Acceleration:
    default: Incomplete
    cd: Incomplete
    v: Incomplete
    lmb: Incomplete
    ratio: Incomplete
    def __init__(self, cd, v, lmb, ratio) -> None: ...
    def __call__(self, value: np.ndarray, dt: float) -> np.ndarray: ...

class KalmanFilter:
    A: Incomplete
    B: Incomplete
    H: Incomplete
    Q: Incomplete
    R: Incomplete
    dim: Incomplete
    I: Incomplete
    x: Incomplete
    P: Incomplete
    def __init__(self, A, B, H, Q, R) -> None: ...
    def copy(self) -> KalmanFilter: ...
    def bias(self, x: np.ndarray) -> np.ndarray: ...
    def debias(self, x: np.ndarray) -> np.ndarray: ...
    def predict(self, c: np.ndarray = ...) -> np.ndarray: ...
    def correct(self, m: np.ndarray, H: np.ndarray = ...) -> np.ndarray: ...
    @classmethod
    def default_xy(cls) -> KalmanFilter: ...
    def predict_xy(self) -> tuple[float, float]: ...
    def step_xy(self, x: float, y: float) -> tuple[float, float]: ...
