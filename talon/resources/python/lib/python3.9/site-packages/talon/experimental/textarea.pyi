from _typeshed import Incomplete
from contextlib import contextmanager as contextmanager
from talon import app as app, clip as clip, cron as cron, ctrl as ctrl, screen as screen, skia as skia
from talon.canvas import Canvas as Canvas, MouseEvent as MouseEvent
from talon.scripting import Dispatch as Dispatch
from talon.types import Point2d as Point2d, Rect as Rect, Span as Span
from typing import Any, Callable, List, Tuple, Union

class Theme:
    title_fg: str
    title_bg: str
    bg: str
    fg: str
    label: str
    underline: str
    selection: str
    padding: float
    text_size: float
    title_size: float
    label_size: float
    typeface: str
    line_spacing: float
    def __init__(self, title_fg, title_bg, bg, fg, label, underline, selection, padding, text_size, title_size, label_size, typeface, line_spacing) -> None: ...

class LightTheme(Theme):
    title_fg: str
    title_bg: str
    bg: str
    fg: str
    label: str
    underline: str
    selection: str
    padding: float
    text_size: float
    title_size: float
    label_size: float
    line_spacing: float
    typeface: str
    def __init__(self, title_fg, title_bg, bg, fg, label, underline, selection, padding, text_size, title_size, label_size, typeface, line_spacing) -> None: ...

class DarkTheme(LightTheme):
    title_fg: str
    title_bg: str
    bg: str
    fg: str
    label: str
    underline: str
    selection: str
    def __init__(self, title_fg, title_bg, bg, fg, label, underline, selection, padding, text_size, title_size, label_size, typeface, line_spacing) -> None: ...

class LightThemeLabels(LightTheme):
    label_size: float
    typeface: str
    def __init__(self, title_fg, title_bg, bg, fg, label, underline, selection, padding, text_size, title_size, label_size, typeface, line_spacing) -> None: ...

class DarkThemeLabels(DarkTheme):
    label_size: float
    typeface: str
    def __init__(self, title_fg, title_bg, bg, fg, label, underline, selection, padding, text_size, title_size, label_size, typeface, line_spacing) -> None: ...

class Key:
    specs: Incomplete
    os: Incomplete
    def __init__(self, *specs: str, os: str = ...) -> None: ...
    def match(self, event): ...
    def __call__(self, fn): ...

class Shortcuts:
    widget: TextArea
    shortcuts: List[Tuple[List[Key], Callable]]
    def undo(self, event, buf) -> None: ...
    def redo(self, event, buf) -> None: ...
    def cut(self, event, buf) -> None: ...
    def copy(self, event, buf) -> None: ...
    def paste(self, event, buf) -> None: ...
    def select_all(self, event, buf) -> None: ...
    def backspace(self, event, buf) -> None: ...
    def delete(self, event, buf) -> None: ...
    def pageup(self, event, buf) -> None: ...
    def pagedown(self, event, buf) -> None: ...
    def up(self, event, buf) -> None: ...
    def down(self, event, buf) -> None: ...
    def line_begin(self, event, buf) -> None: ...
    def line_end(self, event, buf) -> None: ...
    def left(self, event, buf) -> None: ...
    def right(self, event, buf) -> None: ...
    def word_left(self, event, buf) -> None: ...
    def word_right(self, event, buf) -> None: ...
    def default(self, event, buf) -> None: ...
    def __init__(self, widget) -> None: ...

class ArrayFilter:
    obj: Incomplete
    cb: Incomplete
    def __init__(self, obj, cb) -> None: ...
    def __getitem__(self, key: int): ...
    def __len__(self): ...
SliceType = Union[int, slice, Span]
ZeroRect: Incomplete

class LineWrap:
    span: Span
    width: float
    rect: Rect
    glyphs: List[Point2d]
    def __init__(self, span: Span = ..., width: float = ...) -> None: ...
    def __lt__(self, other: LineWrap) -> bool: ...

class Line:
    offset: int
    value: str
    y_line: int
    y_wrap: int
    wraps: List[LineWrap]
    rect: Rect
    def __init__(self, value: str = ...) -> None: ...
    @property
    def right(self) -> int: ...
    def __len__(self) -> int: ...
    def __getslice__(self, key: SliceType) -> slice: ...
    def __getitem__(self, key: SliceType) -> str: ...
    def __setitem__(self, key: SliceType, value: str): ...
    def span(self) -> Span: ...

class UndoStep:
    span: Span
    sel: Span
    text: str
    def __init__(self, span, sel, text) -> None: ...

class Buffer:
    def __init__(self) -> None: ...
    @property
    def theme(self) -> Theme: ...
    @property
    def rect(self) -> Rect: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: SliceType) -> str: ...
    def __edit__(self, key: SliceType, value: str, *, undo: bool = ..., redo: bool = ...): ...
    def __setitem__(self, key: SliceType, value: str): ...
    def __delitem__(self, key: SliceType): ...
    def undo(self) -> None: ...
    def redo(self) -> None: ...
    def line(self, key: SliceType) -> Span: ...
    def lines(self, key: SliceType) -> List[Span]: ...
    def word(self, key: SliceType) -> Span: ...
    def text_to_canvas(self, pos: SliceType) -> Rect: ...
    def canvas_to_text(self, point: Point2d) -> int: ...
    def extent_rect(self) -> Rect: ...

class TextArea(Dispatch):
    def __init__(self) -> None: ...
    @property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str): ...
    @property
    def rect(self) -> Rect: ...
    @rect.setter
    def rect(self, value: Rect): ...
    @property
    def theme(self) -> Theme: ...
    @theme.setter
    def theme(self, value: Theme): ...
    @property
    def value(self) -> str: ...
    @value.setter
    def value(self, value: str): ...
    @property
    def sel(self) -> Any: ...
    @sel.setter
    def sel(self, value: Union[int, Tuple[int, int], Span]): ...
    @property
    def scroll(self) -> int: ...
    @scroll.setter
    def scroll(self, value: int): ...
    @property
    def selected_text(self) -> str: ...
    def __getitem__(self, key: SliceType) -> str: ...
    def insert(self, text: str): ...
    def replace(self, span: Span, text: str): ...
    def erase(self, span: Union[int, Span]): ...
    def delete_selection(self) -> None: ...
    def center(self) -> None: ...
    def show(self) -> None: ...
    def hide(self) -> None: ...
    def line(self, key: SliceType) -> Span: ...
    def lines(self, key: SliceType) -> List[Span]: ...
    def word(self, key: SliceType) -> Span: ...
    def text_to_screen(self, pos: SliceType) -> Rect: ...
    def screen_to_text(self, point: Point2d) -> int: ...
