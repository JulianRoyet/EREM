from functools import singledispatch as singledispatch
from talon.api import ffi as ffi, lib as lib
from talon.types.point import Point2d as Point2d
from typing import Any, Iterable, Tuple, Union, overload

class Rect:
    x: float
    y: float
    width: float
    height: float
    def __init__(self, x: float, y: float, width: float, height: float) -> None: ...
    def copy(self) -> Rect: ...
    @property
    def pos(self) -> Point2d: ...
    @property
    def size(self) -> Point2d: ...
    @property
    def left(self) -> float: ...
    @left.setter
    def left(self, value: float) -> None: ...
    @property
    def right(self) -> float: ...
    @right.setter
    def right(self, value: float) -> None: ...
    @property
    def top(self) -> float: ...
    @top.setter
    def top(self, value: float) -> None: ...
    @property
    def bot(self) -> float: ...
    @bot.setter
    def bot(self, value: float) -> None: ...
    @property
    def center(self) -> Point2d: ...
    @center.setter
    def center(self, value: Union[Tuple[float, float], Point2d]) -> None: ...
    @overload
    def contains(self, pt_or_x: Point2d) -> bool: ...
    @overload
    def contains(self, pt_or_x: float, y: float) -> bool: ...
    def __contains__(self, pt: Point2d) -> bool: ...
    def __add__(self, other: Union['Rect', Point2d]) -> Rect: ...
    def zero(self) -> bool: ...
    def inset(self, amount: float) -> Rect: ...
    def intersect(self, rect: Rect) -> Rect: ...
    def intersects(self, rect: Rect) -> bool: ...
    def distance(self, p: Point2d) -> float: ...
    def clamp(self, p: Point2d) -> Point2d: ...
    def __eq__(self, other: Any) -> bool: ...
    def __iter__(self) -> Iterable[float]: ...
