from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from talon.grammar import Grammar as Grammar
from talon.lib.cubeb import DeviceInfo as DeviceInfo
from talon.scripting import Dispatch as Dispatch
from typing import Any, Dict, Iterable, Optional, Sequence

class WordMeta(str):
    start: Optional[float]
    end: Optional[float]
    type: Optional[str]
    alternate: Optional[str]
    def __new__(typ, value: Any): ...
    @classmethod
    def from_dragon(cls, d: Dict[str, Any]) -> WordMeta: ...
    @property
    def word(self) -> WordMeta: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class EngineError(Exception): ...

class GrammarStatus:
    name: Incomplete
    enabled: Incomplete
    exclusive: Incomplete
    priority: Incomplete
    def __init__(self, name: str, enabled: bool = ..., exclusive: bool = ..., priority: int = ...) -> None: ...

class EngineStatus:
    grammars: Incomplete
    ready: bool
    start_time: float
    language: Incomplete
    def __init__(self) -> None: ...

class AbstractEngine(Dispatch, metaclass=ABCMeta):
    name: str
    subtype: str
    id: str
    need_vad: bool
    @abstractmethod
    def enable(self) -> None: ...
    @abstractmethod
    def disable(self) -> None: ...
    @abstractmethod
    def set_microphone(self, device: Optional[DeviceInfo]) -> None: ...
    @abstractmethod
    def status(self) -> EngineStatus: ...
    @abstractmethod
    def mimic(self, phrase: Sequence[str]) -> None: ...
    @abstractmethod
    def sync_grammar(self, grammar: Grammar) -> None: ...
    @abstractmethod
    def unload_grammar(self, grammar: Grammar) -> None: ...
    @abstractmethod
    def set_vocab(self, words: Iterable[str]) -> None: ...
    @abstractmethod
    def close(self) -> None: ...
