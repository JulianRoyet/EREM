import abc
import threading
from . import AbstractEngine as AbstractEngine, EngineError as EngineError, EngineStatus as EngineStatus, GrammarStatus as GrammarStatus, WordMeta as WordMeta
from _typeshed import Incomplete
from abc import abstractmethod
from pathlib import Path
from talon import app as app, metrics as metrics
from talon.api import ffi as ffi, ffi_string as ffi_string, lib as lib
from talon.debug import log_exception as log_exception
from talon.engines.utils import masked_list as masked_list, transform_samples as transform_samples
from talon.grammar import Grammar as Grammar
from talon.grammar.cfg import CFGLinker as CFGLinker
from talon.grammar.dfa import AlphaWordModel as AlphaWordModel, WordModel as WordModel
from talon.lib import flac as flac
from talon.lib.cubeb import DeviceInfo as DeviceInfo
from talon.nn.w2l import b2l as b2l
from talon.nn.w2l.model import W2lModel as W2lModel, W2lModelFused as W2lModelFused
from talon.scripting import rctx as rctx
from typing import Callable, Iterable, Optional, Sequence
from urllib.parse import urlparse as urlparse

AlignCallable = Callable[[float], float]

class DecodeWord(WordMeta):
    @classmethod
    def from_w2l(cls, handle: ffi.CData, align_cb: AlignCallable) -> DecodeWord: ...

class DecodePath:
    text: Incomplete
    score: Incomplete
    words: Incomplete
    def __init__(self, handle: ffi.CData, align_cb: AlignCallable) -> None: ...

class DecodeResult:
    handle: Incomplete
    greedy_text: Incomplete
    greedy_score: Incomplete
    align_cb: Incomplete
    def __init__(self, handle: ffi.CData, align_cb: AlignCallable) -> None: ...
    def __getitem__(self, i: int) -> DecodePath: ...
    def __len__(self) -> int: ...
    def __del__(self) -> None: ...

class W2lBaseEncoder(metaclass=abc.ABCMeta):
    tokens: list[str]
    criterion: str
    def __init__(self, model: b2l.B2lFile) -> None: ...
    @abstractmethod
    def forward(self, samples: Sequence[float]) -> W2lEmission: ...

class W2lNativeEncoder(W2lBaseEncoder):
    handle: ffi.CData
    def __init__(self, b2l_path: str, model: b2l.B2lFile = ..., ort_patch: bytes = ...) -> None: ...
    def forward(self, samples: Sequence[float]) -> W2lEmission: ...
    def __del__(self) -> None: ...

class W2lTorchEncoder(W2lBaseEncoder):
    model: W2lModelFused
    torch: Incomplete
    def __init__(self, b2l_path: str, model: b2l.B2lFile = ...) -> None: ...
    def forward(self, samples: Sequence[float]) -> W2lEmission: ...

class W2lDecoder:
    handle: Incomplete
    kenlm_path: Incomplete
    lexicon_path: Incomplete
    word_piece: Incomplete
    debug: Incomplete
    lexicon_hash: Incomplete
    opts: Incomplete
    tokens: Incomplete
    sep: str
    def __init__(self, model: b2l.B2lFile, kenlm_path: str, lexicon_path: str, trie_path: str, subtype: str, word_piece: bool, *, debug: bool = ...) -> None: ...
    def load_trie(self, trie_path: str, *, validate: bool = ...) -> None: ...
    def make_trie(self, trie_path: str) -> None: ...
    def decode(self, emission: W2lEmission) -> Sequence[str]: ...
    def decode_greedy(self, emission: W2lEmission) -> Sequence[str]: ...
    def decode_dfa(self, emission: W2lEmission, dfa: bytes) -> Sequence[str]: ...
    def decode_dfa_paths(self, emission: W2lEmission, dfa: bytes, align_cb: AlignCallable) -> DecodeResult: ...
    def __del__(self) -> None: ...

class W2lEmission:
    handle: Incomplete
    retain: Incomplete
    free: Incomplete
    def __init__(self, handle: ffi.CData, *, retain=..., free: bool = ...) -> None: ...
    @property
    def __array_interface__(self): ...
    def __del__(self) -> None: ...

def convert_w2l_to_b2l(path: str) -> None: ...

class W2lBaseEngine(AbstractEngine, metaclass=abc.ABCMeta):
    name: str
    enabled: bool
    grammar: Optional[Grammar]
    cfg_linker: CFGLinker
    language: str
    debug: bool
    lock: threading.RLock
    word_model: WordModel
    need_vad: bool
    loaded: bool
    ready: bool
    def __init__(self, debug: bool = ...) -> None: ...
    @abstractmethod
    def tokens(self) -> list[str]: ...
    @abstractmethod
    def load(self) -> None: ...
    def enable(self) -> None: ...
    def disable(self) -> None: ...
    def set_microphone(self, device: Optional[DeviceInfo]) -> None: ...
    def status(self) -> EngineStatus: ...
    def mimic(self, phrase: Sequence[str]) -> None: ...
    def sync_grammar(self, grammar: Grammar) -> None: ...
    def unload_grammar(self, grammar: Grammar) -> None: ...
    def set_vocab(self, words: Iterable[str]) -> None: ...
    def close(self) -> None: ...

class W2lModelInfo:
    id: str
    name: str
    language: str
    am_path: Path
    lexicon_path: Path
    trie_path: Path
    ngram_path: Optional[Path]
    ort_patch: Optional[bytes]
    @classmethod
    def from_path(self, model: str, language: str = ...) -> W2lModelInfo: ...
    def __init__(self, id, name, language, am_path, lexicon_path, trie_path, ngram_path, ort_patch) -> None: ...

class W2lEngine(W2lBaseEngine):
    encoder: W2lBaseEncoder
    decoder: W2lDecoder
    language: Incomplete
    subtype: Incomplete
    id: Incomplete
    def __init__(self, *, info: W2lModelInfo = ..., model: str = ..., debug: bool = ..., language: str = ..., torch: bool = ...) -> None: ...
    def tokens(self) -> list[str]: ...
    word_model: Incomplete
    cfg_linker: Incomplete
    def load(self) -> None: ...
    def close(self) -> None: ...
