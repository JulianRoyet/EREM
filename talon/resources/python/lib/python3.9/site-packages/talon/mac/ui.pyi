from _typeshed import Incomplete
from talon import cron as cron, events as events, screen as screen, skia as skia
from talon.api import ffi as ffi, ffi_string as ffi_string, lib as lib
from talon.debug import log_exception as log_exception
from talon.lib import debounce as debounce
from talon.screen import Screen as Screen, main_screen as main_screen, screen_containing as screen_containing, screens as screens
from talon.scripting import Dispatch as Dispatch
from talon.types import Point2d as Point2d, Rect as Rect, Size2d as Size2d, Span as Span
from talon.ui import BaseApp as BaseApp, BaseAppStub as BaseAppStub, BaseMonitor as BaseMonitor, BaseWindow as BaseWindow, BaseWindowStub as BaseWindowStub, UIErr as UIErr
from typing import Any, Callable, Dict, Generator, Sequence, Tuple, Union, overload

class Mon(BaseMonitor):
    NoApp: Incomplete
    active_app: Incomplete
    ready: bool
    ready_cond: Incomplete
    def __init__(self) -> None: ...
    def wait_ready(self) -> None: ...
    def mon_event(self, event: str) -> None: ...
    def app_event(self, event: str, cptr: ffi.CData) -> None: ...
    def win_event(self, event: str, cptr: ffi.CData) -> None: ...
    def element_event(self, event: str, app_cptr: ffi.CData, el_cptr: ffi.CData) -> None: ...
    def apps(self, **query: Any) -> Sequence['App']: ...
    def windows(self, **query: Any) -> Sequence['Window']: ...
    def workspaces(self) -> int: ...
    def active_workspace(self) -> int: ...
    def switch_workspace(self, value: int) -> None: ...

class App(BaseApp):
    NoWindow: Incomplete
    mon: Incomplete
    handle: Incomplete
    active_window: Incomplete
    def __init__(self, mon: Mon, app: ffi.CData) -> None: ...
    @property
    def icon(self) -> skia.Image: ...
    @property
    def focused_element(self) -> Element: ...
    @property
    def element(self) -> Element: ...
    def element_at(self, x: float, y: float) -> Element: ...
    def get_background(self) -> bool: ...
    background: Incomplete
    def appscript(self): ...
    def quit(self) -> None: ...
    pid: Incomplete
    name: Incomplete
    path: Incomplete
    exe: Incomplete
    bundle: Incomplete
    created_at: Incomplete
    def update(self) -> None: ...
    def focus(self) -> bool: ...
    def windows(self) -> Sequence['Window']: ...
    @property
    def children(self) -> Elements: ...

class Window(BaseWindow):
    mon: Mon
    app: App
    handle: ffi.CData
    hidden: bool
    def __init__(self, mon: Mon, app: App, window: ffi.CData) -> None: ...
    id: Incomplete
    title: Incomplete
    doc: Incomplete
    def update(self) -> None: ...
    @property
    def element(self) -> Element: ...
    @property
    def workspace(self) -> int: ...
    @workspace.setter
    def workspace(self, value: int): ...
    @property
    def rect(self) -> Rect: ...
    @rect.setter
    def rect(self, rect: Rect) -> None: ...
    @property
    def screen(self) -> Screen: ...
    def appscript(self): ...
    def move(self, x: float, y: float) -> None: ...
    def resize(self, width: float, height: float) -> None: ...
    def focus(self) -> bool: ...
    @property
    def children(self) -> Elements: ...

class AppStub(BaseAppStub):
    mon: Incomplete
    NoWindow: Incomplete
    focused_element: Incomplete
    element: Incomplete
    def __init__(self, mon: Mon) -> None: ...
    def appscript(self) -> None: ...
    @property
    def children(self) -> Elements: ...

class WindowStub(BaseWindowStub):
    mon: Incomplete
    app: Incomplete
    element: Incomplete
    def __init__(self, mon: Mon, app: App) -> None: ...
    def appscript(self) -> None: ...
    @property
    def children(self) -> Elements: ...

class ActionFailed(Exception): ...

class AttrCodec:
    @classmethod
    def object_hook(cls, obj: dict) -> Any: ...
    @classmethod
    def parse_element(cls, value: str) -> Union['Element', str]: ...
    @classmethod
    def decode_recursive(cls, obj: Any) -> Any: ...
    @classmethod
    def default(self, obj: Any) -> dict: ...
    @classmethod
    def dumps(cls, value: Any) -> str: ...
    @classmethod
    def loads(cls, j: bytes) -> Any: ...

class ElementReference:
    handle: ffi.CData
    def __init__(self, handle: ffi.CData) -> None: ...
    @classmethod
    def copy_handle(cls, handle: ffi.CData): ...
    def __del__(self) -> None: ...

class ElementAttrProxy:
    attr: Incomplete
    def __init__(self, ref: ElementReference, attr: str) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...

class Element:
    def __init__(self, ref: ElementReference) -> None: ...
    def __eq__(self, other: Element): ...
    def __neq__(self, other: Element): ...
    @property
    def window_id(self) -> int: ...
    @property
    def window(self) -> Window: ...
    def copy(self) -> Element: ...
    @property
    def attrs(self) -> Tuple[str, ...]: ...
    @property
    def parameterized_attrs(self) -> Tuple[str, ...]: ...
    @property
    def actions(self) -> dict[str, str]: ...
    def __getattr__(self, key: str) -> Any: ...
    def __setattr__(self, key: str, value: Any): ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any): ...
    def get(self, key: str, default: Any = ...) -> Any: ...
    def dump(self) -> dict[str, Any]: ...
    @property
    def parent(self): ...
    @property
    def children(self) -> Elements: ...
    def perform(self, action: str) -> None: ...

class ElementStub(Element):
    def __init__(self) -> None: ...
    def copy(self): ...
    @property
    def attrs(self) -> Tuple[str, ...]: ...
    @property
    def parameterized_attrs(self) -> Tuple[str, ...]: ...
    @property
    def actions(self) -> dict[str, str]: ...
    def __getattr__(self, key: str) -> Any: ...
    def __setattr__(self, key: str, value: Any): ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any): ...
    def get(self, key: str, default: Any = ...) -> Any: ...
    @property
    def children(self) -> Elements: ...
    def find(self, *args, **kwargs) -> Elements: ...
    def find_one(self, *args, **kwargs) -> Elements: ...
    def perform(self, action: str) -> None: ...
    def __del__(self) -> None: ...

class Elements:
    def __init__(self, parent: Element, elements: list[Element] = ...) -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: int) -> Element: ...
    @overload
    def __getitem__(self, key: slice) -> list[Element]: ...
    def __iter__(self) -> Generator[Element, None, None]: ...
    def find(self, *_filters, visible_only: bool = ..., max_results: int = ..., max_visited: int = ..., max_depth: int = ..., timeout: float = ..., prefetch: list[str] = ..., **kwargs) -> Elements: ...
    def find_one(self, *filters, visible_only: bool = ..., max_depth: int = ..., timeout: float = ..., prefetch: list[str] = ..., **kwargs) -> Element: ...

def mon_event(ui: ffi.CData, event: ffi.CData, user: ffi.CData) -> None: ...
def app_event(ui: ffi.CData, app: ffi.CData, event: ffi.CData, user: ffi.CData) -> None: ...
def win_event(ui: ffi.CData, win: ffi.CData, event: ffi.CData, user: ffi.CData) -> None: ...
def element_event(ui: ffi.CData, app: ffi.CData, el: ffi.CData, event: ffi.CData, user: ffi.CData) -> None: ...
def active_app() -> App: ...
def active_window() -> Window: ...
def focused_element() -> Element: ...
def element_at(x: float, y: float) -> Element: ...
def launch(*, bundle: str = ..., path: str = ..., args: Sequence[str] = ..., env: Dict[str, str] = ..., cwd: str = ...) -> int: ...

NoElement: Incomplete
NoElements: Incomplete
apps: Incomplete
windows: Incomplete

def register(topic: str, cb: Callable) -> None: ...
def unregister(topic: str, cb: Callable) -> None: ...
def proxy_screen_change(topic: str, _): ...
