from _typeshed import Incomplete
from traceback import FrameSummary as FrameSummary
from types import FrameType, TracebackType
from typing import Any, Callable, Dict, Generator, Iterator, List, Optional, Tuple, TypeVar

DecoratedT = TypeVar('DecoratedT', bound=Callable[..., Any])
DecoratorType = Callable[[DecoratedT], DecoratedT]
roots: Tuple
stdlib_paths: Tuple

class StackNote:
    tag: Optional[str]
    label: Optional[str]
    collapse: Optional[str]
    def __init__(self, tag, label, collapse) -> None: ...

class StackNotes:
    notes: Dict[int, List[StackNote]]
    def __init__(self) -> None: ...
    def label_frame(self, *, tag: str = ..., label: str = ..., collapse: str = ..., offset: int = ...) -> Iterator[None]: ...
    def label_thread(self, *, tag: str = ..., label: str = ..., collapse: str = ...) -> Iterator[None]: ...
    def collapse_thread(self, *, tag: str, label: str, offset: int = ...) -> Iterator[None]: ...

label_thread: Incomplete
label_frame: Incomplete
collapse_thread: Incomplete

def safe_relpath(path: str, root: str) -> str: ...
def shortest_relpath(path: str) -> str: ...

class StackFrame:
    id: int
    path: str
    line: int
    mod: str
    code: str
    collapsed: bool
    @property
    def short_path(self): ...
    def __init__(self, id, path, line, mod, code, collapsed) -> None: ...

def format_frames(stack: List[StackFrame]) -> List[str]: ...
def frame_stack(frame: FrameType = ..., *, tid: int = ...) -> List[StackFrame]: ...
def frame_tb(tb: TracebackType = ...) -> Tuple[List[StackFrame], str]: ...
def format_tb(tb: TracebackType = ...) -> List[str]: ...
def format_stack(frame: FrameType = ..., *, tid: int = ...) -> List[str]: ...
def print_stack(frame: FrameType = ...) -> None: ...
def splice_tb(stack: List[StackFrame], tb: TracebackType = ...) -> List[str]: ...
def dump_threads() -> str: ...
def print_threads() -> None: ...
def log_exception_chain(e: BaseException = ...) -> List[str]: ...
def log_exception(msg: str) -> None: ...
def object_name(obj: Any, fallback: str = ...) -> str: ...
def objects() -> Iterator[Any]: ...
def timeit(name: str = ...) -> Generator[None, None, None]: ...
